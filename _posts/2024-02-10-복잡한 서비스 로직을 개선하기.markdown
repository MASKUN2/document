---
layout: post
title:  "복잡한 서비스로직을 개선하기"
date:   2024-02-10 00:00:00 +0900
categories: spring
---
### 1.0.0 문제
 아래 다이어그램은 메모수정의 API를 행위다이어그램으로 그린 것이다.
![img.png](img.png)
 트랜젝션의 시작과 종료는 사이의 과정은 서비스가 수행하는 비지니스 로직이다.
 나는 해당 로직을 서비스 메소드 영역안에서 구현했다. 요청데이터와 실제 DB의 데이터를 대조하여 분류하는데 상당한 노력이 들었고 코드가 좋아보이지 않았다. 다음은 내가 구현한 코드의 일부다.
```java
//데이터가 요청 인증정보와 일관성이 있는지 확인하기
        try {
            List<Long> userMemoNoList = reqUserDateMemoList.stream()
                    .map(MemoPutReqDto::memoNo)
                    .filter(Objects::nonNull)
                    .distinct()
                    .toList();
            verifyUpdateRequest(userId, date, userMemoNoList);
        }catch (IllegalArgumentException e){
            log.error("요청정보와 실제 DB의 정보가 일치하지 않습니다.", e);
            throw new MismatchRequestToDbRecordException(e);
        }
        //수정할 요청리스트 구분하기
        List<MemoPutReqDto> updateReqList = filterNeedToUpdate(reqUserDateMemoList);

        //추가할 리스트 만들기 (빈 메모는 대상에 올리지 않음)
        List<MemoPutReqDto> addingList = reqUserDateMemoList.stream()
                .filter(m -> m.memoNo() == null && !(m.memoContent().isBlank()))
                .toList();

        //해당 날짜에 남길 메모 넘버를 구하기
        List<Long> remainMemoNos = updateReqList.stream()
                .map(MemoPutReqDto::memoNo)
                .toList();

        //해달날짜의 남기는 메모를 제외한 나머지 메모를 삭제하기
        removeOtherDateMemos(userId, date, remainMemoNos);
        //메모를 수정하기
        updateMemosContent(updateReqList);
        //메모를 추가하기
        saveMemos(userId, date, addingList);
```
소개되지 않은 다양한 Private 메소드를 호출하고 있다.
filterNeedToUpdate는 요청받은 dtoList 중 수정해야할 것을 선별하는 메소드다.
그 밖에 private 메소드로 추출하지 않았지만 addList 변수가 존재하는데 이것은 filterNeedToUpdate와 비슷하게 추가할 것만 선별하는 메소드다.
그리고 남겨야할 리스트도 remainMemoNos로 선별한다. 
각각 용도별 구분은 비지니스로직을 위해 필요하다. 나의 메모수정기능은 작업단위가 하루일정(date)인데 프론트에서 수정된 해당일정 메모의 스냅샷을 요청dto으로 보낸다. 요청 dto자체는 무엇을 수정해야하는지 또는 추가해야하는지를 담지 않는다. 클라이언트로 보내온 스냅샷을 단순히 받아서 이에 맞도록 서비스로직에서 DB를 수정해주는 것이 해당 메소드의 관건이다. 
 이렇게 API를 설계한 이유는 클라이언트의 요청을 최대한 단순화할 수 있기 때문이었다. 무엇은 삭제, 수정해야하는지 파악하는 일은 서버사이드의 책임이기도 했기 떄문이다. 
 ### 1.0.0.1 구현된 로직의 문제
 그러나 서버사이드에서 이를 구현하는 것은 보기에 쉬워보이지만 설계의 결함이 있어보인다.
  우선 수정 , 삭제 , 추가를 구분해내는 메소드에서 리턴되는 객체가 그대로 다른 멤버 메소드의 인자로 사용되는 것이 문제였다. 이런 연쇄적인 구조는 작은 변경에도 취약할 것이었다. 만약 dto의 데이터구조나 수정대상을 구분하는 조건을 변경하는 요구사항이 있다면, 개발자는 dto를 변경하고 구분하는 메소드도 변경해야하며 이에 영향받는 수정메소드도 이 변경에 영향을 받지 않는지 검사해야한다. 또한 수정/삭제/구별조건이 각각 독립적이기 때문에 어느 하나의 조건규약이 변경되는 경우 다른 구별조건에 영향을 줄 수도 있다. 외부의 변경에 최대한 영향을 적게 받는 것이 좋은 서비스 메소드라고 생각된다면 이는 좋지 못한 코드임이 분명했다.
 ### 1.0.1 해결의 아이디어
 